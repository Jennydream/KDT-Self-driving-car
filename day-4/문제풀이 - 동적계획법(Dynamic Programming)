#알고리즘 

동적 계획법이란?:  주어진 최적화 문제를 재귀적인 방식으로 보다 작은 부분 문제로 나누어 풀고 다시 해를 조합하여 전체 문제의 해답에 이른다. 

  1. top-down- 메모이제이션방식 (재귀)
    ex: 피보나치 재귀함수에서 메모이제이션 사용할 경우 반복부분을 제거 할 수 있음
  2. buttom up 방식 - 반복문 (대체로 이방식을 사용)

  -문제 : N으로 표현 
  
  1,2,3,.... 까지 개수가 증가할 때마다 n일 때 1부터 n-1까지, n-1부터 1까지 사칙 연산을 포함한다.
  숫자 사용 횟수가 증가하면 만들어지는 결과의 수효도 증가. 
  1->1, 2-> 5,3-> 41,  ... 8-> 11853939
  
  겹치는 것을 고려할 경우 8-> 9644까지 감소
 
 1-8까지 각 수가 증가할때 담을 수 있는 set을 생성하여 사용.
  
#문제풀이 

아래와 같이 5와 사칙연산만으로 12를 표현할 수 있습니다.

12 = 5 + 5 + (5 / 5) + (5 / 5)
12 = 55 / 5 + 5 / 5
12 = (55 + 5) / 5

5를 사용한 횟수는 각각 6,5,4 입니다. 그리고 이중 가장 작은 경우는 4입니다.
이처럼 숫자 N과 number가 주어질 때, N과 사칙연산만 사용해서 표현 할 수 있는 방법 중 N 사용횟수의 최솟값을 return 하도록 solution 함수를 작성하세요.

제한사항
N은 1 이상 9 이하입니다.
number는 1 이상 32,000 이하입니다.
수식에는 괄호와 사칙연산만 가능하며 나누기 연산에서 나머지는 무시합니다.
최솟값이 8보다 크면 -1을 return 합니다.

def solution(N, number):

    #5, 55, 555와 같이 각 N의 길에 따른 값을 저장할 set을 생성 (1~9까지 이므로 8개 생성) n=1일 경우 answer=1
    
    s=[set() for i in range(8)]
    answer = 0
    
    # N=5일 때 각 set에 5,55,555,5555 와 같이 기본적인 값을 저장 
    for i , x in enumerate(s, start=1):
        x.add(int(str(N)*i))
     
    # N 길이만큼 각 set에 맞게 계산
    for i in range(len(s)):
        #i=2일 때 j는 1,2와 2,1의 과정 포함. 즉 i 길이 만큼 반복 
        for j in range(i):
            #사칙 연산을 할 피연산자 1 (1,2,3,..)
            for op1 in s[j]:
                #사칙 연산을 할 피연산자 2( n-1, n-2, ... 1)
                for op2 in s[i-j-1]:
                    #각각 사칙 연산 해주고 해당 set에 저장
                    s[i].add(op1+op2)
                    s[i].add(op1-op2)
                    s[i].add(op1*op2)
                    # 만약 나누는 값이 0일경우 예외처리 
                    if op2 !=0:
                        s[i].add(op1//op2)
                        
        #해당 set에서 모든 계산이 끝나면 찾는 수가 set에 있는지 확인하고 있을 경우 값 저장후 중단.
        if number in s[i]:
            answer=i+1
            break
    
    #for 문에서 break를 만나지 않을 경우 조건에 맞는 값을 찾지 못한 것이므로 -1
    else:
        answer=-1
        
    return answer
    

